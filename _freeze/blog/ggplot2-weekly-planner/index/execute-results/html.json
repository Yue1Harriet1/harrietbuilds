{
  "hash": "dd400f3dbcffdd2626d3445c00d2ce29",
  "result": {
    "markdown": "---\ntitle: A Printable Custom Weekly Planner with ggplot2\nauthor: Garrick Aden-Buie\ndate: '2019-06-22'\nslug: ggplot2-weekly-planner\ncategories:\n  - R\n  - ggplot2\n  - Productivity\n  - Scripts\ndescription: \"Use ggplot2 to organize your life.\"\nimage: \"index_files/figure-html/gcal-final-1.png\"\nsource_link: https://github.com/gadenbuie/garrickadenbuie-com/blob/main/content/blog/2019/2019-06-22-ggplot2-weekly-planner.Rmarkdown\nkeywords: rstats\neditor_options:\n  chunk_output_type: console\n---\n\n\n<!-- Links -->\n[tidyverse]: https://tidyverse.org\n[ggweekly]: https://github.com/gadenbuie/ggweekly\n\n\n\n\n\n<!-- Post -->\n\nI was working on prioritizing some long term projects today and decided that _the one thing_ that would help me gain some clarity would be a weekly planner.\nRather than waste hours of productive time fighting popups and banner adds on the million and a half SEO-fueled malware-laden \"free printable calendar\" websites, I decided to waste not quite as many hours of productive time creating the exact calendar I wanted using <span class=\"pkg\">ggplot2</span>.\n\nHere's the end result: a simple calendar where each week is a row.\nWeeks start on Mondays because that's when a new week starts.\nImportant dates can be highlighted, for holidays or other days relevant to your projects.\n\nI doubt it's bullet journal certified, but it worked for me and maybe it will for you too.\n\n::: text-center\n![](index_files/figure-html/gcal-final-1.png){style=\"max-width:500px\"}\n:::\n\nI'll break down the pieces that went into the calendar, but if you just want to make your own you can ~~jump to the end~~ use the [ggweekly] package I shared on GitHub and get straight to calendar printing and project planning.\n\n**Update:** I realized it would be easier to share this code as a small R package rather than a gist or as a script embedded here.\nYou can now install <span class=\"pkg\">ggweekly</span> from [github.com/gadenbuie/ggweekly][ggweekly] and use the `ggweek_planner()` function to make your own custom, printable calendars.\n\n## The Making of a Calendar\n\n### Load the tidyverse\n\nFirst, we need to load the usual suspects from the <span class=\"pkg\">tidyverse], plus the [lubridate</span> package (because dates).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(tidyverse)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(forcats)\nlibrary(ggplot2)\nlibrary(lubridate)\n```\n:::\n\n\nLet's also save ourselves some extra typing and tell <span class=\"pkg\">lubridate</span> to always start weeks with Monday.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\"lubridate.week.start\" = 1)\n```\n:::\n\n\n### Create a tibble of dates\n\nNext, I set up a tibble of dates and associated information (day of the week, month, year, etc.) that I'll need for the calendar grid.\nI start by finding the nearest previous Monday to the starting date and creating a sequence of dates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_day <- floor_date(ymd(\"2019-06-24\"), \"week\")\nend_day   <- ymd(\"2019-08-16\")\nseq_days  <- seq(start_day, end_day, by = \"day\")\n\nseq_days[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2019-06-24\" \"2019-06-25\" \"2019-06-26\" \"2019-06-27\" \"2019-06-28\"\n```\n:::\n:::\n\n\nI'm also taking advantage of the fact that `tibble()` is similar to `mutate()` in that it allows you to create new columns that reference previous columns inside the `tibble` definition, rather than having a separate call to `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <-\n  tibble(\n    day       = seq_days,\n    wday_name = wday(day, label = TRUE, abbr = TRUE),\n    weekend   = wday(day) > 5,\n    isoweek   = isoweek(day),\n    month     = month(day, label = TRUE, abbr = FALSE),\n    isoyear   = isoyear(day),\n    week_year = fct_rev(sprintf(\"%s - %s\", isoyear, isoweek))\n  )\n\ndates\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 54 × 7\n   day        wday_name weekend isoweek month isoyear week_year\n   <date>     <ord>     <lgl>     <dbl> <ord>   <dbl> <fct>    \n 1 2019-06-24 Mon       FALSE        26 June     2019 2019 - 26\n 2 2019-06-25 Tue       FALSE        26 June     2019 2019 - 26\n 3 2019-06-26 Wed       FALSE        26 June     2019 2019 - 26\n 4 2019-06-27 Thu       FALSE        26 June     2019 2019 - 26\n 5 2019-06-28 Fri       FALSE        26 June     2019 2019 - 26\n 6 2019-06-29 Sat       TRUE         26 June     2019 2019 - 26\n 7 2019-06-30 Sun       TRUE         26 June     2019 2019 - 26\n 8 2019-07-01 Mon       FALSE        27 July     2019 2019 - 27\n 9 2019-07-02 Tue       FALSE        27 July     2019 2019 - 27\n10 2019-07-03 Wed       FALSE        27 July     2019 2019 - 27\n# … with 44 more rows\n```\n:::\n:::\n\n\nNote that I've used `isoweek()` and `isoyear()`, which also follow the convention of starting the week on Monday.\nThis way, I now have the week number to which each day in the sequence belongs, but because we may be interested in creating calendars that span multiple years, the addition of `isoyear()` protects against repeated week numbers.\n\nThis week year combination is destined for the *y* axis as it marks the row to which each day belongs.\nThe *y* axis is typically increasing, with the smallest value at the bottom.\nThis means that, if left as strings, the week of `\"2019 - 25\"` would be _below_ the week `\"2019 - 26\"`.\nBecause calendars are typically read top to bottom, I used `fct_rev()` here to both convert `{isoyear} - {isoweek}` into a factor and then reverse the factor order so that `2019 - 25` is the last factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# shows the _last 6_ week_year factor levels\ndates %>% pull(week_year) %>% levels() %>% tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2019 - 31\" \"2019 - 30\" \"2019 - 29\" \"2019 - 28\" \"2019 - 27\" \"2019 - 26\"\n```\n:::\n:::\n\n\nFor a bit of convenience later, I then pull out the rows of `dates` representing the first day of the month, to use later when adding the colored boxes and text labels marking the start of a new month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday_one <- dates %>%\n  filter(day(day) == 1)\n\nday_one\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 7\n  day        wday_name weekend isoweek month  isoyear week_year\n  <date>     <ord>     <lgl>     <dbl> <ord>    <dbl> <fct>    \n1 2019-07-01 Mon       FALSE        27 July      2019 2019 - 27\n2 2019-08-01 Thu       FALSE        31 August    2019 2019 - 31\n```\n:::\n:::\n\n\n### Better week labels\n\nQuick, what's the starting date of week 31 in 2019?\n\nOk, fine, that was too hard.\nWhat month of 2019 does week 31 belong to?\n\nTrick question: that week starts on July 29, 2019 but ends on August 4th.\n\nSo... we need better axis labels than **2019 - 31**.\nA reasonable replacement would be to use the day of the month of the week's starting day.\n\nThe following code filters `dates` to include the first day of each week (hint: it's Monday).\nThen, I use `month(day, label = TRUE)` to get the abbreviated month name (`abbr = TRUE` is the default) that I'll append to the day of the month of each day.\n\nBut when a given week is preceded by a week from the same month, it would be visually distracting to see **Jul** repeated with each date — **Jul  1**, **Jul  8**, **Jul 15**, and so on — in the axis labels.\nFor easy scanning, I only included the month in the label if the month changed from the month before.\nIn other words, when `month == lag(month)`, I just need the day of the month the given week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_start_labels <- dates %>%\n  filter(wday_name == \"Mon\") %>%\n  arrange(day) %>%\n  mutate(\n    month = month(day, label = TRUE),\n    label = case_when(\n      month == lag(month) ~ paste(day(day)),\n      TRUE ~ sprintf(\"%s %4i\", month, day(day))\n    )\n  ) %>%\n  select(label, week_year) %>%\n  reduce(setNames)\n```\n:::\n\n\nThe last two lines there are a neat trick to take a two column `tibble` (or a two-element `list`) and convert it into a named vector using `purrr::reduce()`.\nThe first argument becomes the vector values and second argument becomes the vector names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:5, letters[1:5]) %>% purrr::reduce(setNames)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c d e \n1 2 3 4 5 \n```\n:::\n:::\n\n\n### A special tibble for special days\n\nI used yet another tibble to store holidays and other important dates related to the project.\nEach day can have a `label`, `color`, and/or `fill`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhighlight_days <- tribble(\n         ~ day,            ~ label,   ~ color,    ~ fill,\n  \"2019-07-02\", \"Project Kick Off\", \"#02307a\", \"#02307a\",\n  \"2019-07-04\",         \"July 4th\", \"#b4436c\", \"#b4436c\",\n  \"2019-07-12\",          \"LOI Due\", \"#02307a\", \"#02307a\",\n  \"2019-07-26\",      \"First Draft\", \"#02307a\", \"#02307a\",\n  \"2019-08-05\",        \"Work week\", \"#02307a\", \"#02307a\",\n  \"2019-08-06\",                 \"\",        NA, \"#02307a\",\n  \"2019-08-07\",                 \"\",        NA, \"#02307a\",\n  \"2019-08-08\",                 \"\",        NA, \"#02307a\",\n  \"2019-08-09\",                 \"\",        NA, \"#02307a\",\n  \"2019-08-16\", \"Final Submission\", \"#02307a\", \"#02307a\"\n) %>%\n  mutate_at(vars(day), ymd)\n```\n:::\n\n\n### Finally, ggplot the calendar\n\nFinally, we arrive at the main event, the actual creation of the calendar with <span class=\"pkg\">ggplot2</span>.\n\nHere I use `geom_tile()` for each day, and then overlay tiles for the start-of-the-month days and the highlighted holiday and project-specific days.\nI also used `geom_text()` to add annotations to the special days, which I pushed to the top or bottom left corner of the day box.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to produce the calendar\"}\ngcal <-\n  dates %>%\n  mutate(\n    # Softly fill in the weekend days\n    weekend = case_when(weekend ~ \"#f8f8f8\", TRUE ~ \"#FFFFFF\")\n  ) %>%\n  ggplot() +\n  aes(wday_name, week_year) +\n  # the calendar grid\n  geom_tile(aes(fill = weekend), color = \"#aaaaaa\") +\n  # highlight first day of each month\n  geom_tile(\n    data = day_one,\n    fill = \"#f78154\",\n    alpha = 0.25,\n    width = 1,\n    height = 1\n  ) +\n  # add name of month to the first day\n  geom_text(\n    data = day_one,\n    aes(label = month),\n    family = \"PT Sans Narrow\",\n    color = \"#f78154\",\n    size = 4,\n    # push text to the top left corner\n    hjust = 0,\n    nudge_x = -0.45,\n    vjust = 1,\n    nudge_y = 0.45\n  ) +\n  # highlight project-specific days\n  geom_tile(\n    data = dates %>% inner_join(highlight_days, by = \"day\"),\n    aes(fill = fill),\n    alpha = 0.25\n  ) +\n  # add the label from the highlighted days\n  geom_text(\n    data = dates %>% inner_join(highlight_days, by = \"day\"),\n    aes(label = label, color = color),\n    family = \"PT Sans Narrow\",\n    size = 2,\n    # push to bottom left corner\n    hjust = 0,\n    nudge_x = -0.45,\n    vjust = 0,\n    nudge_y = -0.40\n  ) +\n  scale_x_discrete(position = \"top\") +\n  scale_y_discrete(labels = week_start_labels) +\n  scale_fill_identity() +\n  scale_color_identity() +\n  guides(fill = FALSE) +\n  theme_minimal(base_family = \"PT Sans\") +\n  theme(\n    axis.text = element_text(\"PT Sans Narrow\"),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    axis.text.x.top = element_text(face = \"bold\"),\n    axis.title.x.top = element_blank(),\n  )\n\ngcal\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gcal-1.png){width=672}\n:::\n:::\n\n\n### Calculate month boundaries\n\nFor a final touch, I wanted stronger differentiation between months.\nIn the following code, I convert `wday_name` and `week_year` into integers that indicate the center point of each box.\n\nThen, using the fact that the top and bottom (and right and left) sides of the box are +/- 0.5 units from the center, I create three line segments.\nThe first extends from the bottom left corner of the day starting the week with the month change (left side of the plot) until the _left_ edge of the box representing the start of the next month.\nThe second segment line travels up the left edge of that box.\nAnd the third and final segment travels from the top left corner of the month-changing day to the right edge of the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth_boundaries <- day_one %>%\n  select(day, month, wday_name, week_year) %>%\n  mutate_at(vars(wday_name, week_year), as.integer) %>%\n  mutate(\n    left = map2(wday_name, week_year, ~ {\n      # n/a if month changes on first day\n      if (.x == 1) return(tibble(.missing = NA))\n      tibble(\n        x = 0.5,      xend = .x - 0.5,\n        y = .y - 0.5, yend = y\n      )\n    }),\n    up = map2(wday_name, week_year, ~ {\n      # n/a if month changes on first day\n      if (.x == 1) return(tibble(.missing = NA))\n      tibble(\n        x = .x - 0.5, xend = x,\n        y = .y - 0.5, yend = .y + 0.5\n      )\n    }),\n    right = map2(wday_name, week_year, ~ {\n      tibble(\n        x = .x - 0.5, xend = 7.5,\n        y = .y + 0.5, yend = y\n      )\n    })\n  )\n\n\nmonth_boundaries\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 7\n  day        month  wday_name week_year left             up       right   \n  <date>     <ord>      <int>     <int> <list>           <list>   <list>  \n1 2019-07-01 July           1         7 <tibble [1 × 1]> <tibble> <tibble>\n2 2019-08-01 August         4         3 <tibble [1 × 4]> <tibble> <tibble>\n```\n:::\n:::\n\n\nThen, I use a quick for loop to add each of these segments to the calendar plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (boundary in c(\"left\", \"up\", \"right\")) {\n  gcal <- gcal +\n    geom_segment(\n      data = month_boundaries %>% unnest(!!rlang::sym(boundary)),\n      aes(x = x, y = y, xend = xend, yend = yend),\n      color = \"#999999\",\n      linetype = 2\n    )\n}\n\ngcal\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gcal-final-1.png){width=672 style=\"max-width:500px\"}\n:::\n:::\n\n\n\n## A Weekly Planner Package {#ggweek_planner}\n\nI originally thought I would simply include the code as a gist and move on with life, but I quickly realized that I might want to a) use this code again sometime and b) find some room for improvement and tweaks.\n\nSo I created [ggweekly], a small package for creating calendars like these. In packaging the code, I made a few tweaks and changes.\nFor example, I scraped the dates of federal holidays from the [U.S. Office of Personel Management](https://www.opm.gov/policy-data-oversight/snow-dismissal-procedures/federal-holidays/) and separated the highlighted and holiday days.\nI also tweaked the function signatures a bit to make it more flexible.\n\nCheck out the package at [github.com/gadenbue/ggweekly][ggweekly] and happy planning!\n\n```r\ndevtools::install_github(\"gadenbuie/ggweekly\")\n\n# create a calendar for April, May and June\nlibrary(ggweekly)\nggweek_planner(\n  start_day = \"2019-04-01\",\n  end_day = \"2019-06-30\",\n)\n```\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}