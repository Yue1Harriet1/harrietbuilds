{
  "hash": "e794449058309ac4dc85c28e0940f7d0",
  "result": {
    "markdown": "---\ntitle: Decouple Code and Output in xaringan slides\nauthor: Garrick Aden-Buie\ndate: '2018-08-16'\nslug: decouple-code-and-output-in-xaringan-slides\naliases:\n  - /blog/2018/08/16/decouple-code-and-output-in-xaringan-slides\ncategories:\n  - R\n  - xaringan\n---\n\n\n[xaringan]: https://slides.yihui.name/xaringan/\n[trug]: https://tampausers.github.io/\n[ggplot2]: https://ggplot2.tidyverse.org\n[knitr-chunk-option]: https://yihui.name/knitr/options/\n[trug-ggplot2]: https://gadenbuie.github.io/trug-ggplot2\n[yihui-tip]: https://twitter.com/xieyihui/status/1031033538743857153\n\n\n\n\n\n## Summary\n\nIn this post I demonstrate how the `ref.label` [knitr chunk option][knitr-chunk-option] can be used to decouple  code chunks and their outputs in [xaringan] presentations.\nI give two examples where this could be useful, namely by showing [ggplot2] code and plots [side-by-side](#side-by-side) on the same slide or by placing the plot output [picture-in-picture](#pip) style in the bottom corner of the slide.\n\nYou can see this technique in action in my [presentation on ggplot2][trug-ggplot2].\nOr you can [download the R Markdown source](https://gist.github.com/gadenbuie/3869b688f5e50882e67b684a1e092937) for a minimal xaringan slide deck that demonstrates the whole process.\n\n**Update:** Yihui Xie (the author of `knitr` and `xaringan`) [pointed out on Twitter][yihui-tip] that another valid (and maybe better) option is to use `knitr::fig_chunk()`, and I've added a [demonstration of that approach to this post](#using-knitr-fig-chunk).\nHonestly, if I had known about this function before, it would have been the centerpiece of this blog post!\n\n## Background\n\nA recent tweet by [Gina Reynolds](https://twitter.com/EvaMaeRey) reminded me that I've been sitting on this blog post for a while.\n\n{{ tweet EvaMaeRey 1029104656763572226 >}}\n\nI learned a few [xaringan] tricks[^rmd] when creating\n[my presentation](https://www.garrickadenbuie.com/talk/trug-ggplot2/)\non [ggplot2] for the [Tampa R Users Group][trug],\nand hopefully this blog post makes it easier to replicate than digging through the messy source of that presentation.\n\n[^rmd]: Okay, really these are R Markdown and knitr tricks and if you want to learn more you should definitely check out [R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/).\n\nTo help teach the ggplot2 syntax, I thought it was important to see the code and the plot at the same time, side-by-side.\nUnfortunately, the standard appearance in R Markdown is for the code output to appear immediately following the code chunk that created it, like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(iris) +\n  aes(Sepal.Length, Sepal.Width, color = Species) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## Code and Figure Side-by-Side {#side-by-side}\n\nWhile this looks great on the web or in documents, you quickly run out of vertical space when presenting with the limited screen real estate of a wide-screen television.\nWhat I wanted were slides that look more like this:\n\n\n::: {.cell fig.asp='0.4'}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `data_frame()` was deprecated in tibble 1.1.0.\nâ„¹ Please use `tibble()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nIn general, with xaringan, you use a two column layout by placing the left and right column content inside `.pull-left[]` and `.pull-right[]` respectively.\n\n````markdown\n.pull-left[\n```{r}\n# plot code here\n```\n]\n\n.pull-right[\nPlot output here!\n]\n````\n\nBut the default action of `knitr` will place the plot output inside the `.pull-left[]` block, keeping it in the left column.\n\nTo solve this problem, we need to tell knitr to hold off on evaluating the code output and to place the results in a different chunk.\nWe can accomplish this by setting `eval=FALSE` in the first chunk and using the `ref.label` [code chunk option][knitr-chunk-option] with `echo = FALSE` to output the result in the second:\n\n````markdown\n.pull-left[\n```{r plot-label, eval=FALSE}\n# code chunk here\nggplot(iris) +\n  aes(Sepal.Length,\n      Sepal.Width,\n      color = Species) +\n  geom_point()\n```\n]\n\n.pull-right[\n```{r plot-label-out, ref.label=\"plot-label\", echo=FALSE}\n```\n]\n````\n\n![](pull-left-right.png)\n\nThis works pretty well, but the plots ended up being somewhat squished, so I created two CSS classess for the left and right columns.\n\n```css\n/* custom.css */\n.left-code {\n  color: #777;\n  width: 38%;\n  height: 92%;\n  float: left;\n}\n.right-plot {\n  width: 60%;\n  float: right;\n  padding-left: 1%;\n}\n```\n\nI then used the following options in the YAML header of xaringan\n\n```yaml\noutput:\n  xaringan::moon_reader:\n    css: [\"default\", \"custom.css\"]\n    nature:\n      ratio: 16:9\n```\n\nand changed `.pull-left[]` &#x27A1; `.left-code[]` and `.pull-right[]` &#x27A1; `.right-plot[]`.\n\n````markdown\n.left-code[\n```{r plot-label, eval=FALSE}\n# code chunk here\nggplot(iris) +\n  aes(Sepal.Length,\n      Sepal.Width,\n      color = Species) +\n  geom_point()\n```\n]\n\n.right-plot[\n```{r plot-label-out, ref.label=\"plot-label\", echo=FALSE, fig.dim=c(4.8, 4.5), out.width=\"100%\"}\n```\n]\n````\n\n![](left-code-right-plot.png)\n\nFor best results, notice that I set the figure dimentions to 4.8 x 4.5 -- and aspect ratio of approximately `9 / (16 * 0.6)` -- to match the `.right-plot` width in the CSS.\nI also added `out.width=\"100%\"` so that the image is automatically scaled to fill the column width.\n\nYou can set this once in your setup chunk to apply these settings to all plots so that you don't need to repeat yourself each time.\n\n````markdown\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(fig.dim=c(4.8, 4.5), fig.retina=2, out.width=\"100%\")\n```\n````\n\n## Plot-In-Picture - Plot in Small Callout Box {#pip}\n\nThe _side-by-side_ layout works well when the code is small, but for a plot that requires longer blocks of code, I wanted to be able to see all of the code while still retaining the connection to the plot we were building up.\n\nThe inspiration for this layout is the \"Picture in Picture\" TV feature, where the changes to the plot appear in a small callout image in the slide to preview the changes at each step.\nThen, at the end, we can reveal the final plot in full screen.\n\nThe xaringan portion looks like this\n\n````markdown\n```{r large-plot, eval=FALSE}\nggplot(iris) +\n  aes(Sepal.Length,\n      Sepal.Width,\n      color = Species) +\n  geom_point(size = 4) +\n  labs(x = 'Sepal Length',\n       y = 'Sepal Width') +\n  theme_minimal() +\n  theme(\n    text = element_text(size = 24, family = \"PT Sans\")\n  )\n```\n\n.plot-callout[\n```{r large-plot-callout, ref.label=\"large-plot\", fig.callout=TRUE}\n```\n]\n````\n\nThe `fig.callout=TRUE` is a custom knitr chunk option I created that sets some default chunk values for the callout chunks so that I don't have to repeat these every time I use this layout.\n\n````markdown\n```{r setup, include=FALSE}\nknitr::opts_hooks$set(fig.callout = function(options) {\n  if (options$fig.callout) {\n    options$echo <- FALSE\n    options$out.height <- \"99%\"\n    options$fig.width <- 16\n    options$fig.height <- 8\n  }\n  options\n})\n```\n````\n\nAnd then finally, I used the following CSS to place the callout in the bottom right corner, set the size of the plot and style the plot image inside.\n\n```css\n/* custom.css */\n.plot-callout {\n  height: 225px;\n  width: 450px;\n  bottom: 5%;\n  right: 5%;\n  position: absolute;\n  padding: 0px;\n  z-index: 100;\n}\n.plot-callout img {\n  width: 100%;\n  border: 4px solid #23373B;\n}\n```\n\n![](plot-callout.png)\n\nThen the final plot is revealed on the next slide using `fig.callout=TRUE` but without wrapping the result chunk in side `.plot-callout[]`.\n\n````markdown\n```{r large-plot-full-output, ref.label=\"large-plot\", fig.callout=TRUE}\n```\n````\n\n![](large-plot-full-slide.png)\n\n## Using knitr's fig_chunk() {#using-knitr-fig-chunk}\n\n[Yihui Xie](https://yihui.name) pointed out [on Twitter][yihui-tip] that we can use the chunk option `fig.show=\"hide\"` for the source chunk and then call `knitr::fig_chunk()` directly wherever we want to embed the plot.\nWhat's nice about this approach is `fig_chunk()` outputs the path to the image, so we are completely in control of how that image is embedded into our document.\n\nHe also wrote a [helpful blog post about `fig_chunk()`](https://yihui.name/en/2017/09/knitr-fig-chunk/)\nwhere he describes his motivation for creating this function.\n(Spoiler alert: it is **exactly** the use case described in this blog post!)\nThe help text for the function also helpfully describes our situation to a T:\n\n> This function can be used in an inline R expression to write out the figure filenames without hard-coding them.\n... You can generate plots in a code chunk but not show them inside the code chunk by using the chunk option `fig.show = 'hide'`. Then you can use this function if you want to show them elsewhere.\n\n<pre><code>\n.left-code[\n```{r plot-label-fc, fig.show=\"hide\"}\n# code chunk here\nggplot(iris) +\n  aes(Sepal.Length,\n      Sepal.Width,\n      color = Species) +\n  geom_point()\n```\n]\n\n.right-plot[\n![](`&#x0072; knitr::fig_chunk(\"plot-label-fc\", \"png\")`)\n]\n</code></pre>\n\n![](knitr-fig_chunk.png)\n\n## Wrap Up\n\nIf you want to see the whole process in action, I've compiled a [minimal xaringan presentation](https://gist.github.com/gadenbuie/3869b688f5e50882e67b684a1e092937) that you can download and use as a starting point.\n\nLet me know if this was helpful on Twitter at [&commat;grrrck](https://twitter.com/grrrck) and happy presenting!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}