{
  "hash": "06bc00d06387b744a36b959762fdacbd",
  "result": {
    "markdown": "---\ntitle: \"XML: The Recursive Programming Workout\"\nslug: recursive-xml-workout\ndate: \"2019-11-05\"\ndescription: \"It's like programming Crossfit but with less sweating.\"\nsource_link: \"ihttps://github.com/gadenbuie/garrickadenbuie-com/blob/main/content/blog/2019/2019-11-05-xml-the-recursive-programming-workout.Rmarkdown\"\ncategories:\n  - Blog\ntags:\n  - R\n  - Tips\n  - XML\n  - xml2\n  - purrr\n  - recursive programming\nkeywords:\n  - rstats\n  - R\n  - XML\n  - xml2\n  - purrr\n  - recursive programming\neditor_options:\n  chunk_output_type: console\n---\n\n\n<!-- Links -->\n[xml2]: https://xml2.r-lib.org\n\n\n\n\n\nI had no choice today but to work with raw XML data\nand let me just say: it's been a workout.\n\n<center>\n`{{% tweet \"1191792162909949952\" %}}`{=html}\n</center>\n\n## An example XML file\n\nThe XML file I'm working with primarily stores the data I need in node-level attributes,\nsimilar to the data below that I modified from an example on\n[oracle-base](https://oracle-base.com/articles/misc/xmltable-convert-xml-data-into-rows-and-columns-using-sql#attribute-based-xml).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxml_text <- '\n<company>\n  <employees company=\"MacroSoft\" division=\"Sales\">\n    <employee empno=\"7369\" ename=\"SMITH\" job=\"CLERK\" hiredate=\"17-DEC-1980\"/>\n    <employee empno=\"7499\" ename=\"ALLEN\" job=\"SALESMAN\" hiredate=\"20-FEB-1981\"/>\n    <employee empno=\"7521\" ename=\"WARD\" job=\"SALESMAN\" hiredate=\"22-FEB-1981\"/>\n    <employee empno=\"7566\" ename=\"JONES\" job=\"MANAGER\" hiredate=\"02-APR-1981\"/>\n    <employee empno=\"7654\" ename=\"MARTIN\" job=\"SALESMAN\" hiredate=\"28-SEP-1981\"/>\n  </employees>\n  <employees company=\"MacroSoft\" division=\"Research\">\n    <employee empno=\"7698\" ename=\"BLAKE\" job=\"MANAGER\" hiredate=\"01-MAY-1981\"/>\n    <employee empno=\"7782\" ename=\"CLARK\" job=\"MANAGER\" hiredate=\"09-JUN-1981\"/>\n    <employee empno=\"7788\" ename=\"SCOTT\" job=\"ANALYST\" hiredate=\"19-APR-1987\"/>\n    <employee empno=\"7839\" ename=\"KING\" job=\"PRESIDENT\" hiredate=\"17-NOV-1981\"/>\n    <employee empno=\"7844\" ename=\"TURNER\" job=\"SALESMAN\" hiredate=\"08-SEP-1981\"/>\n    <employee empno=\"7876\" ename=\"ADAMS\" job=\"CLERK\" hiredate=\"23-MAY-1987\"/>\n    <employee empno=\"7900\" ename=\"JAMES\" job=\"CLERK\" hiredate=\"03-DEC-1981\"/>\n    <employee empno=\"7902\" ename=\"FORD\" job=\"ANALYST\" hiredate=\"03-DEC-1981\"/>\n    <employee empno=\"7934\" ename=\"MILLER\" job=\"CLERK\" hiredate=\"23-JAN-1982\"/>\n  </employees>\n</company>\n'\n```\n:::\n\n\n## From XML to a `list()`\n\nWith the <span class=\"pkg\">[xml2]</span> package and two tiny lines of R code\nwe have the XML file as a list in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_xml <- xml2::read_xml(xml_text)\nlist_xml <- xml2::as_list(raw_xml)\n\nstr(list_xml, max.level = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ company:List of 2\n  ..$ employees:List of 5\n  .. ..- attr(*, \"company\")= chr \"MacroSoft\"\n  .. ..- attr(*, \"division\")= chr \"Sales\"\n  ..$ employees:List of 9\n  .. ..- attr(*, \"company\")= chr \"MacroSoft\"\n  .. ..- attr(*, \"division\")= chr \"Research\"\n```\n:::\n:::\n\n\nBut as you can see from the preview above,\nwhen converted to a list,\n<span class=\"pkg\">xml2</span> stores attributes at each node,\nlike `company=\"MacroSoft\"`,\nas R `attributes()` associated with the corresponding list item.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list_xml[[1]][[1]][1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ employee: list()\n  ..- attr(*, \"empno\")= chr \"7369\"\n  ..- attr(*, \"ename\")= chr \"SMITH\"\n  ..- attr(*, \"job\")= chr \"CLERK\"\n  ..- attr(*, \"hiredate\")= chr \"17-DEC-1980\"\n```\n:::\n:::\n\n\n## Promote attributes to list items\n\nI want to extract these attributes and promote them to list-level named entries.\nTo do this I'll use a recursive function,\nmeaning a function that calls itself.\nWhen approaching writing a recursive function,\nit's useful to think of the _base case_ —\nwhen we have or can get the answer that we're looking for —\nand the recursion case —\nor when we need to move further down the tree by calling\nthe function again on a smaller unit.\n\n### Base case\n\nThe base case of the recursive function\nis when we have an empty list that has attributes.\nIn that case, we just return the attributes.\nA good example of the base case from our example XML\nis the `list_xml[[1]][[1]][[1]]` we see above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(list_xml[[1]][[1]][[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$empno\n[1] \"7369\"\n\n$ename\n[1] \"SMITH\"\n\n$job\n[1] \"CLERK\"\n\n$hiredate\n[1] \"17-DEC-1980\"\n```\n:::\n:::\n\n\n### Recursive case\n\nIf,\non the other hand,\nwe find that we have a list that contains both items _and_ attributes\nwe do three things.\nFirst,\nwe keep a copy of the attributes of the list at the current level that we'll use later.\nSecond,\nwe look inside each of the items\nin the list we currently have to see if we can promote their attributes.\nThis triggers the recursion,\nso this function will keep calling itself on smaller\nand smaller units until eventually it reaches a list with no items and only attributes.\nAt that point, it returns the attributes as a list.\n\nThe third and final step is to take the attribute list at the original level and\nconcatenate the list returned from the lower level.\n\nWhen thinking about programming the recusive case,\nI usually try to think about one step above the base case.\nThat is, what would I do if I'm one level above the base case.\nFor this, we can use `list_xml[[1]][[1]]`,\nand, in essence,\nwe want to perform this action:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthis_attr <- attributes(list_xml[[1]][[1]])\nlower_level <- purrr::map(list_xml[[1]][[1]], attributes)\nstr(lower_level)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 5\n $ employee:List of 4\n  ..$ empno   : chr \"7369\"\n  ..$ ename   : chr \"SMITH\"\n  ..$ job     : chr \"CLERK\"\n  ..$ hiredate: chr \"17-DEC-1980\"\n $ employee:List of 4\n  ..$ empno   : chr \"7499\"\n  ..$ ename   : chr \"ALLEN\"\n  ..$ job     : chr \"SALESMAN\"\n  ..$ hiredate: chr \"20-FEB-1981\"\n $ employee:List of 4\n  ..$ empno   : chr \"7521\"\n  ..$ ename   : chr \"WARD\"\n  ..$ job     : chr \"SALESMAN\"\n  ..$ hiredate: chr \"22-FEB-1981\"\n $ employee:List of 4\n  ..$ empno   : chr \"7566\"\n  ..$ ename   : chr \"JONES\"\n  ..$ job     : chr \"MANAGER\"\n  ..$ hiredate: chr \"02-APR-1981\"\n $ employee:List of 4\n  ..$ empno   : chr \"7654\"\n  ..$ ename   : chr \"MARTIN\"\n  ..$ job     : chr \"SALESMAN\"\n  ..$ hiredate: chr \"28-SEP-1981\"\n```\n:::\n\n```{.r .cell-code}\nstr(c(this_attr, lower_level), max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 8\n $ names   : chr [1:5] \"employee\" \"employee\" \"employee\" \"employee\" ...\n $ company : chr \"MacroSoft\"\n $ division: chr \"Sales\"\n $ employee:List of 4\n $ employee:List of 4\n $ employee:List of 4\n $ employee:List of 4\n $ employee:List of 4\n```\n:::\n:::\n\n\n## A recursive attribute-promotor function\n\nThe final step is to put this all together inside a function\nthat handles the base case or recurses to iterate over list items further down the tree.\n\nBut first...\ndid you notice this line above?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ names: chr [1:5] \"employee\" \"employee\" \"employee\" \"employee\" ...\n```\n:::\n:::\n\n\nWe have also included the names of the sub-list items in our new list!\nThis is because R uses named attributes\nto keep track of things like `\"names\"`, `\"class\"`, `\"dimnames\"` etc.\nIf the XML node has an attribute called `names=\"foo\"`,\n<span class=\"pkg\">xml2</span> will store that attribute-value pair as `.names`.\nI don't mind having `.names` entries in my lists\n(I can take care of that downstream),\nbut I don't want to keep attributes named` names` or `class` etc.,\nbecause those are reserved for special R functionality.\n\nHere's a small function that removes reserved R attributes\nfrom the attributes list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_reserved <- function(this_attr) {\n  reserved_attr <- c(\"class\", \"comment\", \"dim\", \"dimnames\", \"names\", \"row.names\", \"tsp\")\n  if (!any(reserved_attr %in% names(this_attr))) {\n    return(this_attr)\n  }\n  for (reserved in reserved_attr) {\n    if (!is.null(this_attr[[reserved]])) this_attr[[reserved]] <- NULL\n  }\n  this_attr\n}\n```\n:::\n\n\nFinally, we can combine everything in a recursive function\nI'll call `promote_attr()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npromote_attr <- function(ll) {\n  this_attr <- attributes(ll)\n  this_attr <- remove_reserved(this_attr)\n  if (length(ll)) {\n    # recursive case\n    c(this_attr, purrr::map(ll, promote_attr))\n  } else {\n    # base case (no sub-items)\n    this_attr\n  }\n}\n```\n:::\n\n\nQuick aside:\nthis function makes very strong assumptions\nthat every item in the list we're recursing over\nis also a list, all the way down.\nIn this example processing a list derived from an XML document,\nit's a reasonable assumption,\nbut one that we should check.\nFor other lists of mixed types,\na whole lot more type checking will be required.\n\n## The end result (for now)\n\nIn the end,\nby mapping `promote_attr()` over `list_xml`,\nwe get a nice, tidy-ish list.\nThis setup might not work for your XML data,\nbut recursive programming can be a huge help when working with lists and tree structures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_xml <- purrr::map(list_xml, promote_attr)\nlistviewer::jsonedit(tidy_xml)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-8996811cbd25c68bb808\" style=\"width:100%;height:425px;\" class=\"widgetframe html-widget \"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-8996811cbd25c68bb808\">{\"x\":{\"url\":\"recursive-xml-workout_files/figure-html//widgets/widget_tidy-xml-listviewer.html\",\"options\":{\"xdomain\":\"*\",\"allowfullscreen\":false,\"lazyload\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Further Reading\n\nIf you'd like to read more about <span class=\"pkg\">purrr</span>\nor about rectangling tangled tree-like lists,\nI highly recommend Jenny Bryan's excellent\n[repurrrsive tutorial and package](https://github.com/jennybc/repurrrsive).\nWith many great practice data sets, challenges, and tips,\nit's an excellent and highly recommended read!\n\n",
    "supporting": [
      "recursive-xml-workout_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/htmlwidgets-1.6.1/htmlwidgets.js\"></script>\n<script src=\"../site_libs/pymjs-1.3.2/pym.v1.js\"></script>\n<script src=\"../site_libs/widgetframe-binding-0.3.1/widgetframe.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}