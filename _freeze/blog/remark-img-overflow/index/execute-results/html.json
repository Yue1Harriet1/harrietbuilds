{
  "hash": "b3cf8c2db06030578ba0379165265e78",
  "result": {
    "markdown": "---\ntitle: Automated Image Overflow Detection for xaringan or remark Slides\nauthor: Garrick Aden-Buie\ndate: '2023-07-21'\nslug: remark-slide-image-overflow\n# image: feature.png\ncategories:\n  - R\n  - Slides\n  - xaringan\ndescription: >\n  Using chromote and a little JavaScript to detect image overflow issues in\n  {xaringan} or remark slides.\nexcerpt: >\n  Using chromote and a little JavaScript to detect image overflow issues in\n  {xaringan} or remark slides.\nsummary: >\n  Using chromote and a little JavaScript to detect image overflow issues in\n  {xaringan} or remark slides.\n\nresources:\n  - example-slide/\n  - \"example-slide/**/*\"\n\neditor_options:\n  chunk_output_type: console\n\neditor:\n  render-on-save: true\n---\n\n\n[renderthis-issue]: https://github.com/jhelvy/renderthis/issues/44\n[renderthis]: https://jhelvy.github.io/renderthis/\n[xaringan]: https://github.com/yihui/xaringan\n[remark]: https://github.com/gnab/remark\n[chromote]: https://github.com/rstudio/chromote\n[post-print-xaringan]: /blog/print-xaringan-chromote/\n[gw-toot]: https://mastodon.social/@gvwilson/110748990146853019\n[xaringan-posts]: /blog/#category=xaringan\n[xaringan-playground]: /blog/xaringan-playground/\n[rmarkdown]: https://rmarkdown.posit.co/\n\n## Awesome slides from plain text\n\nI'm a long-time user and big fan of using the [xaringan] package to create slides[^actually-remark]\n(as you might [know from my blog][xaringan-posts]).\n\n[^actually-remark]: R users know of these slides as [xaringan slides][xaringan], but the underlying technology is [remark][remark], a JavaScript library for creating slides from plain text.\n\nI've always appreciated that you can\nuse [R Markdown][rmarkdown] (or just regular markdown)\nto write your slides,\nbut you can also use HTML, CSS and JavaScript to customize your slides.\nYou can write in plain text,\nor you can [turn each slide into a small web project][xaringan-playground].\n\nWeb-based slides can be shared with others online\nand tend to be more accessible than traditional slide formats.\nAnd with packages like [renderthis] --\na package by [John Helveston](https://github.com/jhelvy) and I --\nyou can even get PDF and other formats easily.\n\n## PDF slides and the case of the missing images\n\nBut PDF slides come with a few challenges of their own,\none of which is that,\nbecause you're essentially using the browser's printing features to render the PDF,\nyou're stuck dealing with some print-related quirks.\n\nThe one that I've seen most often in PDFs\nis that images that happily render in the browser\ncan suddenly dissapear from the PDF version of the slides.\nHere's how I described the problem in [an issue in renderthis][renderthis-issue]:\n\n> Chrome's printing algorithm...excludes images that extend beyond the visible margin from printing. I'm sure [there's a reason for this that] makes sense for general webpage printing, but it does cause problems for slides.\n>\n> It can be hard to tell visually if the plot extends past the margins of the slide because the actual image may include empty space that you can't see.\n\nOne trick I've used quite often is to add a red outline\naround all the images in the slides during development\n(or just before publishing the slides):\n\n```css\nimg, svg {\n  outline: 1px solid red;\n}\n```\n\n## More slides, more problems\n\nThat little CSS trick works well enough\nif you're in the middle of writing the slides,\nbut it'd be a pretty terrible process to have to do this manually\nfor, say, 530 slides a dozen times or more over the next three months.\n\nIf that sounds like an oddly specific example, that's because it is.\nI was reminded of this problem by [Greg Wilson's recent ~bat signal~ toot][gw-toot]:\n\n> _plea for help; macOS; open source; command-line; PDF_\n>\n> dear lazyweb: is there a command-line tool for macos that will take a PDF and produce a 4-up or 6-up PDF? I need to check the layout of a bunch of slides (because I haven't figured out how to get the remark slideshow tool to tell me when an SVG image in a slide overflows, so I'm going to have to eyeball 'em). thank you\n>\n> Greg Wilson [@gvwilson@mastodon.social](https://mastodon.social/@gvwilson) --\n> Jul 20, 2023, 19:24\n\nThis is exactly the kind of task I would want to automate,\nand it's an exquisitely designed and irresistable nerd snipe.\nI've used [chromote] (and headless Chrome) before to\n[automate printing complex xaringan slides][post-print-xaringan],\nso I know there's a good chance its doable.\n\nSo the rest of this post is a quick exploration\nof how to use a remote-controlled browser (via [chromote])\nto load the slides and detect any images that are clipped.\n\n## Example slides\n\nI've created a small example slide deck\nthat has a few slides with images that\n\"accidentally\" go beyond the edges of the slides.\nWe'll use this as our test case.\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"shareagain\" style=\"min-width:300px;margin:1em auto;\" data-exeternal=\"1\">\n<iframe src=\"example-slide/index.html\" width=\"399.999999999999\" height=\"300\" style=\"border:2px solid currentColor;\" loading=\"lazy\" allowfullscreen></iframe>\n<script>fitvids('.shareagain', {players: 'iframe'});</script>\n</div>\n```\n:::\n:::\n\n\n::: {.callout collapse=\"true\"}\n### Source\n\n\n\n````default\n---\ntitle: Image overflow example\noutput:\n  xaringan::moon_reader:\n    seal: false\n    self_contained: false\n---\n\nclass: center middle\n\n# First slide\n\n```{r}\n#| echo: false\nxaringanExtra::use_share_again()\nxaringanExtra::style_share_again(share_buttons = \"none\")\n```\n\n---\n\n# Slide with clipped plot\n\nThis slide makes a plot that won't fit on the slide.\n\n```{r plot, results=\"hide\"}\nhist(faithful$waiting)\n```\n\n---\nclass: bottom right\n\n# Absolutely positioned plot\n\n<img src=\"`r knitr::fig_chunk(\"plot\", ext = \"png\")`\" style=\"position: absolute; top: -2px; left: -20px;\">\n\n---\n\n# SVG too big!\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"800\" height=\"800\" fill=\"currentColor\" class=\"bi bi-bug\" viewBox=\"0 0 16 16\"><path d=\"M4.355.522a.5.5 0 0 1 .623.333l.291.956A4.979 4.979 0 0 1 8 1c1.007 0 1.946.298 2.731.811l.29-.956a.5.5 0 1 1 .957.29l-.41 1.352A4.985 4.985 0 0 1 13 6h.5a.5.5 0 0 0 .5-.5V5a.5.5 0 0 1 1 0v.5A1.5 1.5 0 0 1 13.5 7H13v1h1.5a.5.5 0 0 1 0 1H13v1h.5a1.5 1.5 0 0 1 1.5 1.5v.5a.5.5 0 1 1-1 0v-.5a.5.5 0 0 0-.5-.5H13a5 5 0 0 1-10 0h-.5a.5.5 0 0 0-.5.5v.5a.5.5 0 1 1-1 0v-.5A1.5 1.5 0 0 1 2.5 10H3V9H1.5a.5.5 0 0 1 0-1H3V7h-.5A1.5 1.5 0 0 1 1 5.5V5a.5.5 0 0 1 1 0v.5a.5.5 0 0 0 .5.5H3c0-1.364.547-2.601 1.432-3.503l-.41-1.352a.5.5 0 0 1 .333-.623zM4 7v4a4 4 0 0 0 3.5 3.97V7H4zm4.5 0v7.97A4 4 0 0 0 12 11V7H8.5zM12 6a3.989 3.989 0 0 0-1.334-2.982A3.983 3.983 0 0 0 8 2a3.983 3.983 0 0 0-2.667 1.018A3.989 3.989 0 0 0 4 6h8z\"/></svg>\n\n---\n\nThis little CSS can help during development,\nnot so much once you've built out all of your slides.\n\n```{css eval = FALSE}\nimg, svg { outline: 2px solid red; }\n```\n\n```{css echo = FALSE}\n/* this is the real css I applied\n   to avoid red outlines in the share bar */\n:not(.shareagain-button) > :is(img, svg) {\n  outline: 2px solid red;\n}\n```\n````\n\n:::\n\n## Automate it!\n\nLet's automate all the things!\n(I have to say, I absolutely love taking an annoying manual process\nand turning it into runnable, repeatable code.)\n\nThe basic idea is to do these 4 steps:\n\n1. Fire up headless Chrome and load the slides.\n\n2. Determine the natural desired size of the slides (in pixels) and then set the virtual browser window to this size. This isn't strictly necessary, but it makes the math _much easier_ later on, so it's worth it.\n\n3. Make all of slides visible at once. Otherwise, remark (the JavaScript library that powers the slides) hides all of the slides except the current slide. Elements that are hidden from the browser don't have a size, ruining our ability to detect overflow.\n\n4. Finally, find all of the images in the slides and check if any escape the slide (browser window) boundaries.\n\n### With chromote\n\nNow we get to the fun part.\nFirst we need to start up chromote and initialize a new browser session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(chromote)\n\nchrome <- ChromoteSession$new()\n```\n:::\n\n\nI've stored the example slide deck in a folder called `example-slide`,\nand I've rendered it from `index.Rmd` to `index.html`.\nTo load the file in Chrome,\nwe need the full path to the file,\nprefixed with `file://`,\ne.g. `file:///Users/garrick/.../example-slide/index.html`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslide_path <- file.path(\"example-slide\", \"index.html\")\nslide_path_uri <- file.path(\"file:/\", normalizePath(slide_path))\n```\n:::\n\n\nNow we can load the slides in Chrome.\nI'm using a small trick here\nto make sure that the R session waits for the browser to load the page.\nThe trick is to request the `Page.loadEventFired` event\nvia chromote asynchronously (`wait_ = FALSE`),\nthen load the page,\nafter which the we block the R session until the page load event fires.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npl <- chrome$Page$loadEventFired(wait_ = FALSE)\nchrome$Page$navigate(slide_path_uri, wait_ = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Promise [pending]>\n```\n:::\n\n```{.r .cell-code}\n# Block until the page load event fires\nchrome$wait_for(pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$timestamp\n[1] 190338.4\n```\n:::\n:::\n\n\nThat's not something you usually have to do with chromote\nwhen you're interacting with pages on the web\n(because those take long enough to load),\nbut local pages load very quickly,\nsometimes faster than the R expressions are evaluated.\n(In other words, if you execute the navigate command and\n_then_ wait for page load event, you might miss it.)\n\n### Match window size to slide size\n\nNow that we have our slides loaded in the headless browser,\nwe need to figure out what size they are.\nremark uses some rather random pixels values based on the\nspecified slide ratio,\nso the easiest thing to do is\nfind the first visible size\nand figure out what size remark used.\n\nHere's a small JavaScript function that will do that for us:\n\n\n::: {.cell}\n\n```{.js .cell-code}\nfunction get_slide_size() {\n  // Find the first visible slide in the deck\n  const visible_slide = document\n    .querySelector('.remark-visible .remark-slide-scaler')\n\n  // and inspect it's width and height\n  // knowing that remark will set these values\n  const {width, height} = visible_slide.style\n\n  return {\n    width: parseInt(width),\n    height: parseInt(height)\n  }\n}\n```\n:::\n\n\nWe the use the `$Runtime$evaluate()` methods of the chromote object\nto run the JavaScript function definition.\nBasically, I've put that function definition above into a string and handed it to `chrome$Runtime$evaluate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Loading the function in the browser via chromote\"}\nchrome$Runtime$evaluate(\"\nfunction get_slide_size() {\n  // Find the first visible slide in the deck\n  const visible_slide = document\n    .querySelector('.remark-visible .remark-slide-scaler')\n\n  // and inspect it's width and height\n  // knowing that remark will set these values\n  const {width, height} = visible_slide.style\n\n  return {\n    width: parseInt(width),\n    height: parseInt(height)\n  }\n}\n\")\n```\n:::\n\n\nNow that we've loaded the function in the browser,\nwe can call it to get the size of the slides.\nHere we again use `$Runtime$evaluate()`,\nbut I've added `returnByValue = TRUE` to the call\nto get the result of the JS expression back in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslide_size <-\n  chrome$Runtime$evaluate(\n    \"get_slide_size()\",\n    wait_ = TRUE,\n    returnByValue = TRUE\n  )\n\n# Extract the result we want from Chrome's response\nslide_size <- slide_size$result$value\nslide_size\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$width\n[1] 908\n\n$height\n[1] 681\n```\n:::\n:::\n\n\nWith the slide size in hand,\nwe can set the size of the virtual browser window\nusing the `$Emulation$setVisibleSize()` method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchrome$Emulation$setVisibleSize(\n  height = slide_size$height,\n  width = slide_size$width\n)\n```\n:::\n\n\nIf you wanted to be certain everything is set up correctly,\nyou could call `chrome$view()` now and see the slides your browser's seeing.\n\n![The headless Chrome preview of the slides in a Chrome window.](chromote-view.png)\n\n### Make all slides visible\n\nWith our slides loaded in the browser,\nwe need to make them all visible.\nThis trick involves finding all of the slides in the deck --\nusing the `.remark-slides-area .remark-slide-container` selector --\nand then add the `remark-visible` class to each slide.\nThis is the class that remark toggles to show and hide the slides when you move through them.\n\n\n::: {.cell}\n\n```{.js .cell-code}\ndocument\n  .querySelectorAll('.remark-slides-area .remark-slide-container')\n  .forEach(slide => slide.classList.add('remark-visible'))\n```\n:::\n\n\n### Detect clipped elements\n\nDetecting if an element is clipped is easy now that we've made all the slides visible _and_ set the browser window to match the slide size exactly.\n\nThe core idea in this function is to use the `getBoundingClientRect()` method to get the position of the element relative to the browser window.\nIf any side of the element is outside of the window,\nthen the element is clipped.\n\n\n::: {.cell}\n\n```{.js .cell-code}\nfunction is_element_clipped(el) {\n  const { top, left, bottom, right  } = el.getBoundingClientRect()\n  return top < 0 ||\n    left < 0 ||\n    right > window.innerWidth ||\n    bottom > window.innerHeight\n}\n```\n:::\n\n\nIf we hadn't resized the virtual browser window to match the slide size,\nthen we would have to do figure out the\nslide's size and the element's relative position within it\nto determine if the element is clipped.\n\nIf we've found a clipped element,\nwe can extract some useful information about it\nthat we'll use in R to learn about our problematic images.\nI also threw in a `console.log()` element\nso that, you if were to use this code in a head-full browser,\nyou'd get a nice console message about the clipped image.\n\n\n::: {.cell}\n\n```{.js .cell-code}\nfunction clipped_img_info(el) {\n    // If you're looking at the slides in the browser,\n    // this will logged the clipped images in the console.\n    console.log(\"clipped image\", el)\n\n    return {\n      img_tag: el.tagName,\n      img_src: /^data:/.test(el.src) ? el.src.slice(0, 32) : el.src,\n      img_class: el.classList.toString(),\n      slide_heading: el.closest('.remark-slide')\n        .querySelector('h1, h2, h3, h4, h5, h6')\n        ?.innerText,\n      slide_text: el.closest('.remark-slide').innerText,\n    }\n  }\n```\n:::\n\n\nNow we're at the best part.\nWe use `.querySelectorAll()` to find all images (or SVGs) in our slides,\nfilter them to include only those that are clipped,\nand then extract the information we need\nabout the clipped images.\n\n\n::: {.cell}\n\n```{.js .cell-code}\ndocument\n  .querySelectorAll(\n    '.remark-slides-area .remark-slide :is(img, svg)'\n  )\n  .filter(is_element_clipped)\n  .map(clipped_img_info)\n```\n:::\n\n\n### Find all the clipped images\n\n\n\n\n\nTo make life a little easier,\nI wrote all of the above JavaScript code\ninto a file called [`find-bad-images.js`](find-bad-images.js).\nIf you want, you can download that file and use it directly.\nHere, I'll read the contents\nand pass the string of JavaScript to chromote\nto get the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_images <-\n  chrome$Runtime$evaluate(\n    paste(readLines(\"find-bad-images.js\"), collapse = \"\\n\"),\n    wait_ = TRUE,\n    returnByValue = TRUE\n  )\n```\n:::\n\n\nWith a little bit of data reshaping,\nwe've got a nice table of all the images\nwe need to fix in our slides.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_images$result$value |>\n  purrr::map_dfr(~ .) |>\n  dplyr::mutate(img_src = basename(img_src))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  img_tag img_src    img_class   slide_heading              slide_text          \n  <chr>   <chr>      <chr>       <chr>                      <chr>               \n1 IMG     plot-1.png \"\"          Slide with clipped plot    \"Slide with clipped…\n2 IMG     plot-1.png \"\"          Absolutely positioned plot \"Absolutely positio…\n3 svg     <NA>       \"bi bi-bug\" SVG too big!               \"SVG too big!\\n4 / …\n```\n:::\n:::\n\n::: {.cell}\n<style type=\"text/css\">\n.code-annotation-gutter {\n  background-color: inherit;\n}\n</style>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/fitvids-2.1.1/fitvids.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}