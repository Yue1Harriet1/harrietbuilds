---
title: Read and Visualize your Twitter Archive
author: Garrick Aden-Buie
date: '2022-11-12'
slug: tweet-archive-in-r
categories:
  - Blog
tags:
  - R
  - Twitter
  - Personal Data
description: |
  Using R to read and visualize your Twitter archive data. Featuring {ggiraph},
  {ggplot2}, {jsonlite}, {dplyr} and more...
source_link: 'https://github.com/gadenbuie/garrickadenbuie-com/blob/main/content/blog/2022/tweet-archive-in-r/index.Rmarkdown'
keywords: rstats
editor_options:
  chunk_output_type: console
---

<!-- Links -->
[rtweet]: https://docs.ropensci.org/rtweet

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 9, 
  fig.height = 10
)
options(htmltools.dir.version = TRUE, crayon.enabled = TRUE, crayon.colors = 256)
```

```{r setup-fansi, comment="", results="asis", echo = FALSE}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
```

## Reading your Twitter archive

### Get your Twitter data archive

First things first, you need to have your Twitter data archive.
If you don't have it yet,
go to [Settings and Privacy](https://twitter.com/settings/account) and
click [Download an archive of your data](https://twitter.com/settings/download_your_data).
After you submit the request,
it takes about a day or so for an email to show up in your inbox.

> \@grrrck your Twitter data is ready
>
> Your Twitter archive is ready for you to download and view using your desktop browser. Make sure you download it before Nov 12, 2022, 9:46:31 PM

The archive downloads as a zip file containing a standalone web page —
called `Your archive.html` —
for exploring your data.
But the real archive lives in the included `data/` folder as a bunch of `.js` files.
I've copied that `data/` directory into my working directory for this post.

### Setup

On the R side,
we'll need the usual suspects: tidyverse and glue.

```{r setup-r, message = TRUE}
library(tidyverse)
library(glue)
```

(I'm using the dev version of [tidyverse]{.pkg} (1.3.2.9000),
which loads [lubridate]{.pkg} automatically,
and the dev version of [purrr]{.pkg} to test out the new features.)

To read in the data files,
I'll use [jsonlite](https://github.com/jeroen/jsonlite) to read the archive JSON data,
with a small assist from [brio](https://brio.r-lib.org)
for fast file reading.

I'm also going to have some fun with
[ggiraph](https://davidgohel.github.io/ggiraph/)
for turning static ggplot2 plots into interactive plots.

Finally, the Twitter archive doesn't _require_ API access to Twitter,
but you can use it to augment the data in the archive.
The [rtweet] package is excellent for this,
even though it takes a little effort to 
[get it set up](https://docs.ropensci.org/rtweet/articles/rtweet.html).

### Read the manifest

The `data/` folder is suprisingly well structured!
There are two key files to help you find your way around the archive.
First, the `README.txt` file explains the structure and layout of the files,
and includes descriptions of the data contained in all of the files.

Here's how the README describes the `account.js` data file:

```
account.js
- email: Email address currently associated with the account if an email address has been provided.
- createdVia: Client application used when the account was created. For example: “web” if the  account was created from a browser.
- username: The account’s current @username. Note that the @username may change but the account ID will remain the same for the lifetime of the account.
- accountId: Unique identifier for the account.
- createdAt: Date and time when the account was created.
- accountDisplayName: The account’s name as displayed on the profile.
```

The `data/` folder also contains a `manifest.js` file
that can be used to help read the data included in the archive.

Let's start by assuming this file is JSON and reading it in.

```{r try, error = TRUE}
jsonlite::fromJSON("data/manifest.js")
```

The archive files are packages as JSON,
but they're not strictly compliant JSON files;
they include some JavaScript to assign objects
to a `YTD` object in the global namespace
(called `window` in the browser).

```{r manifest-lines}
lines <- brio::read_lines("data/manifest.js")
writeLines(c(
  lines[1], 
  "  // ... data ...", 
  lines[length(lines)]
))
```

If we just take the last character of the first line —
the `{` or sometimes `[` —
we can turn the data into valid JSON.

```{r manifest-read-first}
lines[1] <- substring(lines[1], nchar(lines[1]))
manifest <- jsonlite::fromJSON(lines)
```

This worked!
But I'm not happy with the structure.
[jsonlite]{.pkg} was designed for statistical work,
so it transforms the data structure a bit while reading in the data.
Sometimes that's helpful,
but more frequently I find that I want to keep the data structure in R
as close to the original JSON data structure as possible.
My solution is to suppress matrix and data.frame simplifications
and only allow [jsonlite]{.pkg}
to simplify vectors.
While I'm at it,
I'll put both the JSON parsing and the first line substitution
into the same helper function.

```{r read_archive_json}
read_archive_json <- function(path) {
  lines <- brio::read_lines(path)
  lines[1] <- substring(lines[1], nchar(lines[1]))
  
  jsonlite::fromJSON(
    txt = lines, 
    simplifyVector = TRUE, 
    simplifyDataFrame = FALSE,
    simplifyMatrix = FALSE
  )
}
```

Now we're ready to read the manifest again.
```{r manifest-1}
manifest <- read_archive_json("data/manifest.js")
names(manifest)
```
The manifest file contains some information about the user and the archive,
```{r manifest-2}
str(manifest$userInfo)
```
plus details about all of the various data included in the archive,
like the data about my `account`.
```{r manifest-3}
str(manifest$dataTypes$account)
```
Each `dataType` in the manifest
points us to a file (or files) in the archive
and helpfully tells us how many records are included.

Here are the data files with the most records.

```{r}
manifest$dataTypes |>
  # All data types we can read have a "files" item
  keep(~ "files" %in% names(.x)) |>
  # We keep the files objects but still as a list of lists within a list
  map("files") |>
  # Turn the files into tibbles (list of tibbles within a list)
  map_depth(2, as_tibble) |>
  # Then combine the files tables for each item keeping track of the file index
  map(list_rbind, names_to = "index") |> 
  # And finally combine files for all items
  list_rbind(names_to = "item") |>
  mutate(across(count, as.integer)) |>
  slice_max(count, n = 15) |>
  knitr::kable()
```


### Reading the account data file

For a first example, let's read the `data/account.js` archive file.
Looking in `manifest$dataTypes$account`
tells us which files hold the account data
and how many records are in each.

```{r}
manifest$dataTypes$account |> str()
```

Here there's only one file containing a single account record: `data/account.js`.
Inside _that_ file is a small bit of JavaScript.
It's _almost_ JSON, 
except that it assigns the JavaScript object to `window.YTD.account.part0`.

```{js file=manifest$dataTypes$account$files[[1]]$fileName, eval = FALSE}

```

As we saw before,
if we clean up the first line,
this is valid JSON that we can read in directly with [jsonlite]{.pkg}.

```{r collapse = TRUE}
account <- read_archive_json("data/account.js")
str(account)
```

```{r joined-stats, echo = FALSE}
joined <- ymd_hms(account[[1]]$account$createdAt)

joined_duration <- 
  interval(start = joined, end = now()) |> 
  as.duration()
```

This leads us to our first fun fact:
I created my Twitter account on
`r strftime(joined, "%B %d, %Y")`, 
which means that I've been using Twitter (on and off) for
`r sprintf("%0.1f", joined_duration / dyears())` years.
That's `r format(floor(joined_duration / ddays()), big.mark = ",")` days of twittering!

### Read any archive item

Let's generalize what we learned into a few helper functions we can reuse.
I've placed everything into a single code block
so that you can copy and paste it into your R session or script
to use it right away.

```{r collapse = TRUE}
#' Read the Twitter Archive JSON 
#' 
#' @param path Path to a Twitter archve `.js` file
read_archive_json <- function(path) {
  lines <- brio::read_lines(path)
  lines[1] <- substring(lines[1], nchar(lines[1]))
  
  jsonlite::fromJSON(
    txt = lines, 
    simplifyVector = TRUE, 
    simplifyDataFrame = FALSE,
    simplifyMatrix = FALSE
  )
}

#' Read an twitter archive data item
#' 
#' @param manifest The list from `manifest.js`
#' @param item The name of an item in the manifest
read_twitter_data <- function(manifest, item) {
  manifest$dataTypes[[item]]$files |> 
    purrr::transpose() |>
    purrr::pmap(\(fileName, ...) read_archive_json(fileName))
}

#' Simplify the data, if possible and easy
#' 
#' @param x A list of lists as returned from `read_twitter_data()`
#' @param simplifier A function that's applied to each item in the list of lists
#'   and that can be used to simplify the output data.
simplify_twitter_data <- function(x, simplifier = identity) {
   x <- purrr::flatten(x)
   item_names <- x |> purrr::map(names) |> purrr::reduce(union)
   if (length(item_names) > 1) return(x)
   
   x |>
    purrr::map(item_names) |>
    purrr::map_dfr(simplifier)
}
```

Let's use this on another archive item
to find the earliest Twitter adopters among my followers.
First we read in the `"follower"` item
and use the `simplify_twitter_data()` function
to get the results in a nice, rectangular table.
(`simplify_twitter_data()` is an optional step because it's an 80/20 function:
it's 20% of the code that does the right thing 80% of the time.)

```{r early_followers}
# These tables are wide, you may need to scroll to see the preview
options(width = 120)

followers <- 
  read_twitter_data(manifest, "follower") |>
  simplify_twitter_data()

early_followers <- 
  followers |>
  ## The above line is basically the following two lines
  # pluck(1) |>
  # map_dfr("follower") |>
  mutate(across(accountId, as.numeric)) |>
  arrange(accountId) |>
  slice_head(n = 11)

# Top 11 earliest followers
early_followers
```

As you can see,
the archive often includes the barest minimum amount of data.
Thankfully, we can still use [rtweet] to gather additional data about these users.
I'm looking at a small subset of my 
`r format(nrow(followers), big.mark = ",")`
here,
but you might want to do this for all your followers
and save the collected user data in your archive.

```{r early_followers_full}
early_followers_accounts <- 
  early_followers |>
  pull(accountId) |>
  rtweet::lookup_users()

early_followers_accounts |>
  select(id, name, screen_name, created_at, followers_count, description)
```


## My tweets

```{r tweets_raw}
# Tweets are a list of a list of tweets...
tweet <- read_twitter_data(manifest, "tweets")[[1]][[105]]$tweet
str(tweet, max.level = 2)
```

```{r tweet_tidy_raw}
tweet_tidy_raw <- function(tweet_raw) {
  basic_items <- c(
    "created_at",
    "favorite_count",
    "retweet_count",
    "full_text",
    "id",
    "lang",
    "source"
  )
  
  tweet <- tweet_raw[basic_items]
  tweet$created_at <- strptime(tweet$created_at, "%a %b %d %T %z %Y")
  tweet$retweet <- grepl("^RT @", tweet$full_text)
  tweet$reply <- grepl("^@", tweet$full_text)
  tweet$user_mentions <- tweet_raw |> 
    purrr::pluck("entities", "user_mentions") |>
    purrr::map_chr("screen_name") |>
    paste(collapse = ",")
  tweet$hashtags <- tweet_raw |> 
    purrr::pluck("entities", "hashtags") |>
    purrr::map_chr("text") |>
    paste(collapse = ",")
  tweet
}
```

```{r}
tweet_tidy_raw(tweet) |> str()
```


```{r tweets}
tidy_tweets <- 
  read_twitter_data(manifest, "tweets") |> 
  simplify_twitter_data(tweet_tidy_raw) |> 
  mutate(
    across(contains("_count"), as.integer),
    type = case_when(
      retweet ~ "retweet",
      reply ~ "reply",
      TRUE ~ "tweet"
    ),
    hour = hour(created_at),
    day = wday(created_at, label = TRUE, abbr = TRUE, week_start = 1),
    month = month(created_at, label = TRUE, abbr = FALSE),
    day_of_month = day(created_at),
    year = year(created_at)
  ) |> 
  filter(!id %in% c("2954171516", "2930539208"))
```

## Monthly tweets, replies and retweets


````{=html}
<details class="pa2 ba br2 b--custom-border-color"><summary class="pa2 pointer">Code: Set Blog Theme</summary>
```{r set-theme}
blog_theme <-
  theme_minimal(18, base_family = "IBM Plex Mono") +
  theme(
    plot.background = element_rect(fill = "#f9fafa", color = NA),
    plot.title.position = "plot",
    legend.position = c(0, 1),
    legend.direction = "horizontal",
    legend.justification = c(0, 1),
    legend.title.align = 1,
    axis.title.y = element_text(hjust = 0),
    axis.title.x = element_text(hjust = 0),
    panel.grid.major = element_line(color = "#d3d9db"),
    # panel.grid.minor = element_line(color = "#e7eaeb")
    panel.grid.minor = element_blank()
  )

theme_set(blog_theme)
```
</details>
````


````{=html}
<details class="pa2 ba br2 b--custom-border-color"><summary class="pa2 pointer">Code: Plot Monthly Tweets</summary>
```{r plot-monthly, eval = FALSE, echo = TRUE}
type_colors <- c(reply = "#5e5b7f", tweet = "#ef8c02", retweet = "#7ab26f")

plot_monthly <-
  tidy_tweets |>
  mutate(dt_month = floor_date(created_at, "month")) |>
  group_nest(dt_month, month, year, type) |>
  mutate(
    n = map_int(data, nrow),
    top = data |>
      map(
        slice_max,
        n = 5,
        order_by = retweet_count * 2 + favorite_count,
        with_ties = FALSE
      ) |>
      map(pull, full_text) |>
      map(str_trunc, width = 120)
  ) |>
  select(-data) |>
  rowwise() |>
  mutate(
    type_pl = plu::ral(type, n = n),
    tooltip = glue::glue(
      "<p><strong>{month} {year}: ", 
      "<span style=\"color:{type_colors[type]}\">{n} {type_pl}</span></strong></p>",
      "<ol>{tweets}</ol>",
      tweets = paste(sprintf("<li>%s</li>", top), collapse = "")
    ),
    tooltip = htmltools::HTML(tooltip)
  ) |> 
  ungroup() |>
  mutate(type = factor(type, rev(c("tweet", "reply", "retweet")))) |>
  arrange(dt_month, type) |>
  ggplot() +
  aes(x = dt_month, y = n, fill = type, group = type) +
  ggiraph::geom_col_interactive(
    width = 31 * 24 * 60 * 60,
    aes(tooltip = tooltip)
  ) +
  scale_fill_manual(values = type_colors) +
  scale_x_datetime(
    date_breaks = "1 year", 
    date_labels = "%Y",
    expand = expansion()
  ) +
  scale_y_continuous(expand = expansion(add = c(1, 1))) +
  labs(
    title = "Tweets per month",
    x = "Month Tweeted →",
    y = "Count →",
    fill = NULL
  )

ggiraph::girafe(
  ggobj = plot_monthly, 
  width_svg = 14, 
  height_svg = 6,
)
```
</details>
````

::: {#plot-monthly}
```{r ref.label="plot-monthly", echo = FALSE, eval = TRUE}

```
:::

## Popular tweets, likes & retweets

````{=html}
<details class="pa2 ba br2 b--custom-border-color"><summary class="pa2 pointer">Code: Plot Popular Tweets</summary>
```{r plot-popular-tweets, echo = TRUE, eval = FALSE}
plot_popular_tweets <- 
  tidy_tweets |>
  filter(retweet_count >= 10, favorite_count >= 5) |>
  mutate(
    age = as.numeric(difftime(Sys.time(), created_at, units = "days")) / 365.25,
    created_at = strftime(created_at, '%a %b %e, %Y'),
    tooltip = glue(
      "<p>{full_text}</p>",
      "<dl><dt>&#9842;</dt><dd>{retweet_count}</dd>", 
      "<dt>&#9829;</dt><dd>{favorite_count}</dt>", 
      "<dt>&#9998;</dt><dd><a href=\"https://twitter.com/grrrck/status/{id}\">{created_at}</a></dd></dl>"
    )
  ) |>
  ggplot() +
  aes(
    x = favorite_count,
    y = retweet_count,
    color = age,
    size = 5 * retweet_count + favorite_count,
    tooltip = tooltip
  ) +
  ggiraph::geom_point_interactive() +
  scale_color_viridis_c(option = "C", direction = -1) +
  scale_y_continuous(trans = scales::log1p_trans(), breaks = c(25, 50, 100, 200, 400)) +
  scale_x_continuous(trans = scales::log1p_trans(), breaks = c(25, 50, 100, 200, 400, 800, 1600)) +
  guides(size = "none") +
  labs(
    title = "Popular tweets",
    x = "Favorites →",
    y = "Retweets →",
    color = "Tweet age\nin years"
  ) +
  theme(
    legend.title = element_text(size = 12, vjust = 1),
    legend.position = c(1.0125, 1.08),
    legend.justification = c(1, 1)
  )

ggiraph::girafe(
  ggobj = plot_popular_tweets, 
  width_svg = 12, 
  height_svg = 8,
  options = list(
    ggiraph::opts_toolbar(position = "bottomright"),
    ggiraph::opts_tooltip(placement = "container"),
    ggiraph::opts_hover_inv("color:var(--borderColorCustom, #cfd5d8)")
  )
)
```
</details>
````

::: {#plot-popular-tweets}
```{r ref.label="plot-popular-tweets", echo = FALSE, eval = TRUE}

```
:::

```{js echo = FALSE}
function addPlotPopularTweetPlaceholderText () {
  const el = document.querySelector('#plot-popular-tweets [class^="tooltip_svg_"]')
  if (!el) {
    setTimeout(addPlotPopularTweetPlaceholderText, 500)
    return;
  }
  el.innerHTML = '<p class="silver i">Hover over a point above to see the original tweet.</p>'
}
document.addEventListener('DOMContentLoaded', addPlotPopularTweetPlaceholderText)
```

## Tweets by time of day

````{=html}
<details class="pa2 ba br2 b--custom-border-color"><summary class="pa2 pointer">Code: Plot Tweets by Time of Day</summary>
```{r plot-time-of-day, eval = FALSE}
tweet_count_by_hour <- 
  tidy_tweets |>
  count(day, hour) |>
  mutate(
    hour_label = case_when(
      hour == 12 ~ "12pm",
      hour == 0 ~ "12am",
      hour > 12 ~ paste0(hour - 12, "pm"),
      hour < 12 ~ paste0(hour, "am")
    ),
    pct = n / sum(n)
  )

tooltip_hour <- function(day, hour_label, ...) {
  this_hour_count <- 
    tweet_count_by_hour |> 
    filter(hour_label == !!hour_label)
  
  this_hour_total <- sum(this_hour_count$n)
  this_hour_pct <- scales::percent(this_hour_total / sum(tweet_count_by_hour$n), 0.1)
  this_hour_total <- trimws(format(this_hour_total, big.mark = ","))
  
  this_hour_days <- 
    this_hour_count |> 
    mutate(
      across(pct, scales::percent_format(0.1)),
      across(n, format, big.mark = ","),
      across(n, trimws),
      text = glue("{day}: {pct} ({n})"),
      text = if_else(day == !!day, glue("<strong>{text}</strong>"), text)
    ) |> 
    glue_data("<li>{text}</li>") |>
    glue_collapse()
  
  glue::glue(
    "<p><strong>{hour_label}</strong><br><small>{this_hour_pct} of total ({this_hour_total})</small></p>", 
    "<ul>{this_hour_days}</ul>"
  )
}

tweet_count_by_hour$tooltip <- pmap_chr(tweet_count_by_hour, tooltip_hour)

plot_time_of_day <-
  ggplot(tweet_count_by_hour ) +
  aes(y = n, fill = day, x = hour, data_id = hour, tooltip = tooltip) +
  geom_area(
    data = function(d) {
      # Shade from midnight-6am and 6pm-midnight, kinda like geom_step_area()
      max_count <- max(d$n)
      tibble(
        day = sort(rep(unique(d$day), 6)),
        hour = rep(c(0, 6, 6.01, 18, 18.01, 24), 7),
        n = rep(c(max_count, max_count, 0, 0, max_count, max_count), 7),
        tooltip = ""
      )
    },
    fill = "#aaaaaa30",
  ) +
  ggiraph::geom_col_interactive(show.legend = FALSE, width = 1) +
  facet_wrap(vars(day), nrow = 2) +
  coord_polar(start = pi) +
  scale_x_continuous(
    breaks = seq(0, 23, 3),
    minor_breaks = 0:23,
    labels = c("12am", paste0(seq(3, 9, 3), "am"), "12pm", paste0(seq(3, 9, 3), "pm")),
    limits = c(0, 24),
    expand = expansion()
  ) +
  scale_y_continuous(expand = expansion(), breaks = seq(0, 100, 25)) +
  scale_fill_discrete() +
  labs(
    title = "When do I do my tweeting?",
    x = NULL,
    y = NULL
  ) +
  theme(
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 10),
    panel.grid.major.y = element_blank()
  )

ggiraph::girafe(
  ggobj = plot_time_of_day,
  width_svg = 12, 
  height_svg = 8,
  options = list(
    ggiraph::opts_hover_inv("filter: saturate(30%) brightness(125%)"),
    ggiraph::opts_hover(css = "opacity:1"),
    ggiraph::opts_tooltip(
      placement = "container",
      css = "width: 12rem; font-family: var(--font-monospace, 'IBM Plex Mono');",
      offx = 625,
      offy = 250,
      use_cursor_pos = FALSE
    )
  )
)
```
</details>
````

::: {#plot-time-of-day}
```{r ref.label = "plot-time-of-day", echo = FALSE}
```
:::

## Tweet Source

````{=html}
<details class="pa2 ba br2 b--custom-border-color"><summary class="pa2 pointer">Code: Plot Tweet Source</summary>
```{r plot-tweet-source, echo = TRUE, eval = FALSE}
plot_tweet_source <-
  tidy_tweets |>
  extract(source, into = c("source_href", "source"), regex = '<a href="([^"]+)"[^>]+>([^<]+)</a>') |> 
  mutate(
    source = fct_lump_n(source, n = 15),
    source = fct_rev(fct_infreq(source))
  ) |>
  count(source, type, sort = TRUE) |> 
  pivot_wider(names_from = type, values_from = n, values_fill = 0) |>
  mutate(
    total = reply + retweet + tweet,
    tooltip = pmap_chr(
      list(reply, retweet, tweet, total),
      function(reply, retweet, tweet, total) {
        x <- glue(
          '<label for="{tolower(label)}">{label}</label>',
          '<progress id="{tolower(label)}" max="{total}" value="{value}">{value}</progress>',
          label = c("Tweets", "Replies", "Retweets"),
          value = c(tweet, reply, retweet)
        )
        glue_collapse(x)
      }
    )
  ) |> 
  ggplot() +
  aes(x = total, y = source, tooltip = tooltip) +
  ggiraph::geom_col_interactive(show.legend = FALSE) +
  scale_x_continuous(expand = expansion(add = c(0, 0.01))) +
  scale_y_discrete(expand = expansion()) +
  labs(
    title = "What app did I use to tweet?",
    x = "Tweets →",
    y = NULL
  )

ggiraph::girafe(
  ggobj = plot_tweet_source,
  width_svg = 12, 
  height_svg = 8,
  options = list(
    ggiraph::opts_hover_inv("filter: saturate(30%) brightness(125%)"),
    ggiraph::opts_hover(css = "opacity:1"),
    ggiraph::opts_tooltip(
      placement = "container",
      css = "width: 12rem; font-family: var(--font-monospace, 'IBM Plex Mono');"
    )
  )
)
```
</details>
````

::: {#plot-tweet-source}
```{r ref.label="plot-tweet-source", eval = TRUE, echo = FALSE}
```
:::


## My likes

```{r likes-extract, width = 120}
likes <-
  read_twitter_data(manifest, "like") |> 
  simplify_twitter_data()

likes |> 
  arrange(as.numeric(tweetId))
```

While the likes archive includes the full text of each tweet,
we can use the 
[`lookup_tweets()` function](https://docs.ropensci.org/rtweet/reference/lookup_tweets.html)
from the
[rtweet](https://docs.ropensci.org/rtweet/) package
to download complete information about each tweet.

```{r hydrate-likes, eval = FALSE}
likes_full <- 
  rtweet::lookup_tweets(likes$tweetId) |>
  write_rds("data/likes.rds")
```

Getting all `r format(nrow(likes), big.mark = ",")` tweets takes a few minutes,
so I highly recommend saving the data to disk as soon as you've collected it.

```{r likes_full}
likes_full <- read_rds("data/likes.rds")
likes_full
```

```{r likes_full_time}
plot_liked_tweets <-
  likes_full |>
  count(year = year(created_at)) |>
  mutate(
    noun = map_chr(n, \(n) plu::ral("tweet", n = n)),
    tooltip = paste(format(n, big.mark = ","), "liked", noun)
  ) |>
  ggplot() +
  aes(year, n, tooltip = tooltip, group = 1) +
  geom_line(color = "#595959", size = 1.5) +
  ggiraph::geom_point_interactive(color = "#595959", size = 4) +
  scale_x_continuous(breaks = seq(2008, 2022, 2), expand = expansion(add = 0.25)) +
  labs(
    title = "Tweets I've Liked",
    x = "Year →",
    y = "Liked Tweets →"
  )

ggiraph::girafe(
  ggobj = plot_liked_tweets,
  width_svg = 12,
  height_svg = 4,
  options = list(ggiraph::opts_tooltip())
)
```


<!-- CSS Post Customizations -->

```{r echo = FALSE}
xaringanExtra::use_clipboard()
```

```{css echo=FALSE}
[class^="tooltip_svg_"] {
  background: var(--siteBgColorCustom);
  color: var(--textColorCustom);
  font-size: 0.75rem;
  padding: 1rem;
  max-width: 48rem;
  border-radius: 3px;
  box-shadow: 0.3px 0.5px 0.7px hsl(var(--shadow-color) / 0.36), 0.8px 1.6px 2px -0.8px hsl(var(--shadow-color) / 0.36), 2.1px 4.1px 5.2px -1.7px hsl(var(--shadow-color) / 0.36), 5px 10px 12.6px -2.5px hsl(var(--shadow-color) / 0.36);
  --shadow-color: 180deg 3% 61%;
}
[class^="tooltip_svg_"] + [class^="tooltip_svg_"] {
  max-width: 32rem;
}
[class^="tooltip_svg_"] ul, [class^="tooltip_svg_"] ol {
  padding-left: 1rem;
}
[class^="tooltip_svg_"] li {
  line-height: 1.5;
}
[class^="tooltip_svg_"] > :first-child {
  margin-top: 0;
}
[class^="tooltip_svg_"] > :last-child {
  margin-bottom: 0;
}
[class^="tooltip_svg_"] dd, [class^="tooltip_svg_"] dt {
  display: inline-block;
}
[class^="tooltip_svg_"] dd + dt {
  margin-left: 1em;
}
[class^="tooltip_svg_"] dd {
  margin-left: 0.25em;
  font-weight: bold;
}
[class^="tooltip_svg_"] p {
  font-size: 1rem;
}
.girafe_container_std g > g > rect:first-child:last-child,
.girafe_container_std g > g > rect[fill="#F9FAFA"] {
  fill: var(--siteBgColorCustom);
  stroke: var(--siteBgColorCustom);
}
.girafe_container_std text {
  fill: var(--textColorCustom);
}
.girafe_container_std rect[fill="#595959"] { /* default bar color */
	fill: var(--blue-40);
}
.girafe_container_std polyline[stroke="#595959"] { /* geom_line */
	stroke: var(--blue-40);
}
.girafe_container_std circle[fill="#595959"] {  /* geom_circle */
	fill: var(--blue-50);
	stroke: var(--blue-50);
}
#plot-popular-tweets [class^="tooltip_svg_"] {
  opacity: 1 !important;
  margin-left: auto;
  margin-right: auto;
  position: static !important;
  max-width: 32rem;
  pointer-events: visible;
}
#plot-time-of-day [class^="tooltip_svg_"] {
  box-shadow: none;
  text-align: left;
  opacity: 1!important;
  left: unset !important;
  top: unset !important;
  right: -4vw;
  bottom: 2.6rem;
  background: unset;
}
#plot-time-of-day [class^="tooltip_svg_"] p {
  margin-bottom: 0;
}
#plot-time-of-day [class^="tooltip_svg_"] ul {
  list-style: none;
  padding-left: 0;
}
#plot-tweet-source [class^="tooltip_svg_"] {
  text-align: left;
}
#plot-tweet-source [class^="tooltip_svg_"] progress + label {
  margin-top: 0.5rem;
  display: inline-block;
}
#plot-tweet-source [class^="tooltip_svg_"] progress {
  -webkit-appearance: none;
  appearance: none;
  height: 0.66rem;
  border-radius: 0;
  border: none;
  width: 100%;
  background: none;
  margin-top: 5px;
}
#plot-tweet-source [class^="tooltip_svg_"] progress::-webkit-progress-bar {
  background: none;
}
#plot-tweet-source [class^="tooltip_svg_"] progress::-webkit-progress-value {
  background: var(--pink-40);
}
#plot-tweet-source [class^="tooltip_svg_"] progress::-moz-progress-bar {
  background: var(--pink-40);
}
@media (max-width: 48rem) {
  #plot-time-of-day [class^="tooltip_svg_"],
  #plot-popular-tweets [class^="tooltip_svg_"] {
    margin-left; auto;
    margin-right: auto;
    position:   static !important;
    margin-left: auto;
  }
}
@media (prefers-color-scheme: dark) {  
  .girafe_container_std polyline[stroke="#E7EAEB"] {
    stroke: var(--slate-10)
  }
  .girafe_container_std polyline[stroke="#D3D9DB"] {
    stroke: var(--slate-20)
  }
  [class^="tooltip_svg_"] {
    --shadow-color: 203deg 60% 1%;
  }
}
```